#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import typing
from.element import*
from.minium_object import MiniumObject,timeout
class Page(MiniumObject):
 def __init__(self,page_id,path,query,connection):
  super().__init__()
  self.page_id=page_id
  self.path=path
  self.query=query
  self.connection=connection
 def __repr__(self):
  return "Page(id={0}, path={1}, query={2})".format(self.page_id,self.path,self.query)
 @property
 def data(self):
  return self._send("Page.getData").result.data
 def wait_data_contains(self,*keys_list,max_timeout=10):
  @timeout(max_timeout)
  def f():
   d=self.data
   for keys in keys_list:
    obj=d
    for key in keys:
     if obj and key in obj:
      obj=obj[key]
     else:
      return False
   return True
  try:
   f()
   return True
  except TimeoutError:
   return False
 @data.setter
 def data(self,data):
  self._send("Page.setData",{"data":data})
 def element_is_exists(self,selector,max_timeout=10):
  return self._element_is_exists(selector=selector,max_timeout=max_timeout)
 def get_element(self,selector,inner_text=None,value=None,text_contains=None,max_timeout=0)->BaseElement or VideoElement or AudioElement or ViewElement or FormElement or LivePlayerElement or LivePusherElement:
  def _element_filter():
   elements=self._get_elements(selector,max_timeout)
   for element in elements:
    if inner_text and element.inner_text!=inner_text:
     continue
    if value and element.value()!=value:
     continue
    if text_contains and text_contains not in element.inner_text:
     continue
    return element
   return None
  r=_element_filter()
  return r
 def call_method(self,method,args=None):
  if not args:
   args=[]
  if isinstance(args,dict):
   args=[args]
  return self._send("Page.callMethod",{"method":method,"args":args})
 def get_elements(self,selector,max_timeout=20)->typing.List[BaseElement]:
  return self._get_elements(selector,max_timeout)
 @property
 def inner_size(self):
  size_arr=self._get_window_properties(["innerWidth","innerHeight"])
  return{"width":size_arr[0],"height":size_arr[1]}
 @property
 def scroll_height(self):
  return self._get_window_properties(["document.documentElement.scrollHeight"])[0]
 @property
 def scroll_width(self):
  return self._get_window_properties(["document.documentElement.scrollWidth"])[0]
 @property
 def scroll_x(self):
  return self._get_window_properties(["scrollX"])[0]
 @property
 def scroll_y(self):
  return self._get_window_properties(["scrollY"])[0]
 def _get_window_properties(self,names=None):
  if names is None:
   names=[]
  return self._send("Page.getWindowProperties",{"names":names}).result.properties
 def scroll_to(self,scroll_top,duration=300):
  self.call_wx_method("pageScrollTo",[{"scrollTop":scroll_top,"duration":duration}])
 def _send(self,method,params=None):
  if params is None:
   params={}
  params["pageId"]=self.page_id
  return self.connection.send(method,params)
 def _get_elements(self,selector,max_timeout=0)->typing.List[BaseElement]:
  @timeout(max_timeout)
  def search_elements():
   elements=[]
   ret=self._send("Page.getElements",{"selector":selector})
   if hasattr(ret,"error"):
    raise Exception("Error when finding elements[%s], %s"%(selector,ret.error))
   for el in ret.result.elements:
    if "nodeId" in el.keys():
     element_cus=CustomElement(el,self.page_id,self.connection)
     elements.append(element_cus)
    else:
     element=ELEMENT_TYPE.get(el.tagName,BaseElement)(el,self.page_id,self.connection)
     elements.append(element)
   return elements
  try:
   self.logger.info("try to get elements: %s"%selector)
   els=search_elements()
   if len(els)==0:
    self.logger.warning(f"Could not found any element '{selector}' you need")
   else:
    self.logger.info("find elements success: %s"%str(els))
   return els
  except Exception as e:
   raise Exception("elements search fail cause: "+str(e))
 def _element_is_exists(self,selector,max_timeout=10)->bool:
  @timeout(max_timeout)
  def refresh_elements():
   ret=self._send("Page.getElements",{"selector":selector})
   if hasattr(ret,"error"):
    raise Exception("Element not found with selector: [%s], cause: %s"%(selector,ret.error))
   if len(ret.result.elements)>0:
    return True
  try:
   self.logger.info("try to find elements: %s"%selector)
   rtn=refresh_elements()
   self.logger.info("element(%s) exists"%selector)
   return rtn
  except Exception as e:
   self.logger.warning("element(%s) not exists"%selector)
   return False
# Created by pyminifier (https://github.com/liftoff/pyminifier)
